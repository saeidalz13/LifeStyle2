// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: getExpenses.sql

package db

import (
	"context"
	"database/sql"
)

const countCapitalRows = `-- name: CountCapitalRows :one
SELECT COUNT(*)
FROM capital_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND description LIKE $3
`

type CountCapitalRowsParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
}

func (q *Queries) CountCapitalRows(ctx context.Context, arg CountCapitalRowsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCapitalRows, arg.UserID, arg.BudgetID, arg.Description)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEatoutRows = `-- name: CountEatoutRows :one
SELECT COUNT(*)
FROM eatout_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND description LIKE $3
`

type CountEatoutRowsParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
}

func (q *Queries) CountEatoutRows(ctx context.Context, arg CountEatoutRowsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEatoutRows, arg.UserID, arg.BudgetID, arg.Description)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEntertainmentRows = `-- name: CountEntertainmentRows :one
SELECT COUNT(*)
FROM entertainment_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND description LIKE $3
`

type CountEntertainmentRowsParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
}

func (q *Queries) CountEntertainmentRows(ctx context.Context, arg CountEntertainmentRowsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEntertainmentRows, arg.UserID, arg.BudgetID, arg.Description)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const fetchAllCapitalExpenses = `-- name: FetchAllCapitalExpenses :many
SELECT capital_exp_id, expenses, description, created_at
FROM capital_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND description LIKE $3
ORDER by created_at DESC
LIMIT $4 OFFSET $5
`

type FetchAllCapitalExpensesParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

type FetchAllCapitalExpensesRow struct {
	CapitalExpID int64        `json:"capital_exp_id"`
	Expenses     string       `json:"expenses"`
	Description  string       `json:"description"`
	CreatedAt    sql.NullTime `json:"created_at"`
}

func (q *Queries) FetchAllCapitalExpenses(ctx context.Context, arg FetchAllCapitalExpensesParams) ([]FetchAllCapitalExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllCapitalExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Description,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchAllCapitalExpensesRow{}
	for rows.Next() {
		var i FetchAllCapitalExpensesRow
		if err := rows.Scan(
			&i.CapitalExpID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAllEatoutExpenses = `-- name: FetchAllEatoutExpenses :many
SELECT eatout_exp_id, expenses, description, created_at
FROM eatout_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND (
        $3 = '%%' OR
        description LIKE $3
    )
ORDER by created_at DESC
LIMIT $4 OFFSET $5
`

type FetchAllEatoutExpensesParams struct {
	UserID   int64       `json:"user_id"`
	BudgetID int64       `json:"budget_id"`
	Column3  interface{} `json:"column_3"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type FetchAllEatoutExpensesRow struct {
	EatoutExpID int64        `json:"eatout_exp_id"`
	Expenses    string       `json:"expenses"`
	Description string       `json:"description"`
	CreatedAt   sql.NullTime `json:"created_at"`
}

func (q *Queries) FetchAllEatoutExpenses(ctx context.Context, arg FetchAllEatoutExpensesParams) ([]FetchAllEatoutExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllEatoutExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchAllEatoutExpensesRow{}
	for rows.Next() {
		var i FetchAllEatoutExpensesRow
		if err := rows.Scan(
			&i.EatoutExpID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAllEntertainmentExpenses = `-- name: FetchAllEntertainmentExpenses :many
SELECT entertainment_exp_id, expenses, description, created_at
FROM entertainment_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND description LIKE $3
ORDER by created_at DESC
LIMIT $4 OFFSET $5
`

type FetchAllEntertainmentExpensesParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

type FetchAllEntertainmentExpensesRow struct {
	EntertainmentExpID int64        `json:"entertainment_exp_id"`
	Expenses           string       `json:"expenses"`
	Description        string       `json:"description"`
	CreatedAt          sql.NullTime `json:"created_at"`
}

func (q *Queries) FetchAllEntertainmentExpenses(ctx context.Context, arg FetchAllEntertainmentExpensesParams) ([]FetchAllEntertainmentExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllEntertainmentExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Description,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchAllEntertainmentExpensesRow{}
	for rows.Next() {
		var i FetchAllEntertainmentExpensesRow
		if err := rows.Scan(
			&i.EntertainmentExpID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSingleCapitalExpense = `-- name: FetchSingleCapitalExpense :one
SELECT capital_exp_id, budget_id, user_id, expenses, description, created_at
FROM capital_expenses
WHERE capital_exp_id = $1
`

func (q *Queries) FetchSingleCapitalExpense(ctx context.Context, capitalExpID int64) (CapitalExpense, error) {
	row := q.db.QueryRowContext(ctx, fetchSingleCapitalExpense, capitalExpID)
	var i CapitalExpense
	err := row.Scan(
		&i.CapitalExpID,
		&i.BudgetID,
		&i.UserID,
		&i.Expenses,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const fetchSingleEatoutExpense = `-- name: FetchSingleEatoutExpense :one
SELECT eatout_exp_id, budget_id, user_id, expenses, description, created_at
FROM eatout_expenses
WHERE eatout_exp_id = $1
`

func (q *Queries) FetchSingleEatoutExpense(ctx context.Context, eatoutExpID int64) (EatoutExpense, error) {
	row := q.db.QueryRowContext(ctx, fetchSingleEatoutExpense, eatoutExpID)
	var i EatoutExpense
	err := row.Scan(
		&i.EatoutExpID,
		&i.BudgetID,
		&i.UserID,
		&i.Expenses,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const fetchSingleEntertainmentExpense = `-- name: FetchSingleEntertainmentExpense :one
SELECT entertainment_exp_id, budget_id, user_id, expenses, description, created_at
FROM entertainment_expenses
WHERE entertainment_exp_id = $1
`

func (q *Queries) FetchSingleEntertainmentExpense(ctx context.Context, entertainmentExpID int64) (EntertainmentExpense, error) {
	row := q.db.QueryRowContext(ctx, fetchSingleEntertainmentExpense, entertainmentExpID)
	var i EntertainmentExpense
	err := row.Scan(
		&i.EntertainmentExpID,
		&i.BudgetID,
		&i.UserID,
		&i.Expenses,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}
