// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: getExpenses.sql

package db

import (
	"context"
)

const countCapitalRows = `-- name: CountCapitalRows :one
SELECT COUNT(*)
FROM capital_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND LOWER(description) LIKE LOWER($3)
`

type CountCapitalRowsParams struct {
	UserID   int64  `json:"user_id"`
	BudgetID int64  `json:"budget_id"`
	Lower    string `json:"lower"`
}

func (q *Queries) CountCapitalRows(ctx context.Context, arg CountCapitalRowsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCapitalRows, arg.UserID, arg.BudgetID, arg.Lower)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEatoutRows = `-- name: CountEatoutRows :one
SELECT COUNT(*)
FROM eatout_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND LOWER(description) LIKE LOWER($3)
`

type CountEatoutRowsParams struct {
	UserID   int64  `json:"user_id"`
	BudgetID int64  `json:"budget_id"`
	Lower    string `json:"lower"`
}

func (q *Queries) CountEatoutRows(ctx context.Context, arg CountEatoutRowsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEatoutRows, arg.UserID, arg.BudgetID, arg.Lower)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEntertainmentRows = `-- name: CountEntertainmentRows :one
SELECT COUNT(*)
FROM entertainment_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND LOWER(description) LIKE LOWER($3)
`

type CountEntertainmentRowsParams struct {
	UserID   int64  `json:"user_id"`
	BudgetID int64  `json:"budget_id"`
	Lower    string `json:"lower"`
}

func (q *Queries) CountEntertainmentRows(ctx context.Context, arg CountEntertainmentRowsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEntertainmentRows, arg.UserID, arg.BudgetID, arg.Lower)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const fetchAllCapitalExpenses = `-- name: FetchAllCapitalExpenses :many
SELECT capital_exp_id, budget_id, user_id, expenses, description, created_at
FROM capital_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND LOWER(description) LIKE LOWER($3)
ORDER by created_at DESC
LIMIT $4 OFFSET $5
`

type FetchAllCapitalExpensesParams struct {
	UserID   int64  `json:"user_id"`
	BudgetID int64  `json:"budget_id"`
	Lower    string `json:"lower"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) FetchAllCapitalExpenses(ctx context.Context, arg FetchAllCapitalExpensesParams) ([]CapitalExpense, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllCapitalExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Lower,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CapitalExpense{}
	for rows.Next() {
		var i CapitalExpense
		if err := rows.Scan(
			&i.CapitalExpID,
			&i.BudgetID,
			&i.UserID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAllEatoutExpenses = `-- name: FetchAllEatoutExpenses :many
SELECT eatout_exp_id, budget_id, user_id, expenses, description, created_at
FROM eatout_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND LOWER(description) LIKE LOWER($3)
ORDER by created_at DESC
LIMIT $4 OFFSET $5
`

type FetchAllEatoutExpensesParams struct {
	UserID   int64  `json:"user_id"`
	BudgetID int64  `json:"budget_id"`
	Lower    string `json:"lower"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) FetchAllEatoutExpenses(ctx context.Context, arg FetchAllEatoutExpensesParams) ([]EatoutExpense, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllEatoutExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Lower,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EatoutExpense{}
	for rows.Next() {
		var i EatoutExpense
		if err := rows.Scan(
			&i.EatoutExpID,
			&i.BudgetID,
			&i.UserID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAllEntertainmentExpenses = `-- name: FetchAllEntertainmentExpenses :many
SELECT entertainment_exp_id, budget_id, user_id, expenses, description, created_at
FROM entertainment_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND LOWER(description) LIKE LOWER($3)
ORDER by created_at DESC
LIMIT $4 OFFSET $5
`

type FetchAllEntertainmentExpensesParams struct {
	UserID   int64  `json:"user_id"`
	BudgetID int64  `json:"budget_id"`
	Lower    string `json:"lower"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) FetchAllEntertainmentExpenses(ctx context.Context, arg FetchAllEntertainmentExpensesParams) ([]EntertainmentExpense, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllEntertainmentExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Lower,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntertainmentExpense{}
	for rows.Next() {
		var i EntertainmentExpense
		if err := rows.Scan(
			&i.EntertainmentExpID,
			&i.BudgetID,
			&i.UserID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSingleCapitalExpense = `-- name: FetchSingleCapitalExpense :one
SELECT capital_exp_id, budget_id, user_id, expenses, description, created_at
FROM capital_expenses
WHERE capital_exp_id = $1
`

func (q *Queries) FetchSingleCapitalExpense(ctx context.Context, capitalExpID int64) (CapitalExpense, error) {
	row := q.db.QueryRowContext(ctx, fetchSingleCapitalExpense, capitalExpID)
	var i CapitalExpense
	err := row.Scan(
		&i.CapitalExpID,
		&i.BudgetID,
		&i.UserID,
		&i.Expenses,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const fetchSingleEatoutExpense = `-- name: FetchSingleEatoutExpense :one
SELECT eatout_exp_id, budget_id, user_id, expenses, description, created_at
FROM eatout_expenses
WHERE eatout_exp_id = $1
`

func (q *Queries) FetchSingleEatoutExpense(ctx context.Context, eatoutExpID int64) (EatoutExpense, error) {
	row := q.db.QueryRowContext(ctx, fetchSingleEatoutExpense, eatoutExpID)
	var i EatoutExpense
	err := row.Scan(
		&i.EatoutExpID,
		&i.BudgetID,
		&i.UserID,
		&i.Expenses,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const fetchSingleEntertainmentExpense = `-- name: FetchSingleEntertainmentExpense :one
SELECT entertainment_exp_id, budget_id, user_id, expenses, description, created_at
FROM entertainment_expenses
WHERE entertainment_exp_id = $1
`

func (q *Queries) FetchSingleEntertainmentExpense(ctx context.Context, entertainmentExpID int64) (EntertainmentExpense, error) {
	row := q.db.QueryRowContext(ctx, fetchSingleEntertainmentExpense, entertainmentExpID)
	var i EntertainmentExpense
	err := row.Scan(
		&i.EntertainmentExpID,
		&i.BudgetID,
		&i.UserID,
		&i.Expenses,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}
